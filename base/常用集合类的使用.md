## 常用的几种java集合类总结

### 一：直观框架图

简单版：

![][1]

详细版：

  ![img](https://upload-images.jianshu.io/upload_images/2243690-9cd9c896e0d512ed.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/643)

Java集合框架

Java集合框架主要包括两种类型的容器，一种是集合（Collection），另一种是图（Map）。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。Map常用的有HashMap,LinkedHashMap等。

### 二、Collection接口

**1.List**

List接口扩展自Collection，它可以定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。下面介绍List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。

**1.1ArrayList**

通过阅读ArrayList的源码，我们可以很清楚地看到里面的逻辑，它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。

```
1、找到add()实现方法。

   public boolean add(E e) {
   
        ensureCapacityInternal(size + 1);  // Increments modCount!!
       
        elementData[size++] = e;
        
        return true;
    }

2、此方法主要是确定将要创建的数组大小。

  private void ensureCapacityInternal(int minCapacity) {

        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);

    }

    private void ensureExplicitCapacity(int minCapacity) {

       modCount++;

        if (minCapacity - elementData.length > 0){
        
           grow(minCapacity);
           
        }
    }

3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。

    private void grow(int minCapacity) {

        // overflow-conscious code

        int oldCapacity = elementData.length;

        int newCapacity = oldCapacity + (oldCapacity >> 1);

        if (newCapacity - minCapacity < 0){
        
            newCapacity = minCapacity;
        
        }

        if (newCapacity - MAX_ARRAY_SIZE > 0){
        
            newCapacity = hugeCapacity(minCapacity);
            
        }

        // minCapacity is usually close to size, so this is a win:

        elementData = Arrays.copyOf(elementData, newCapacity);

    }
```

**1.2LinkedList**

同样，我们打开LinkedList的源文件，不难看到LinkedList是在一个链表中存储元素。

在学习数据结构的时候，我们知道链表和数组的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同，同样，ArrayList与LinkedList也是如此，实际使用中我们需要根据特定的需求选用合适的类，如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList。

**1.3CopyOnWriteArrayList**

CopyOnWriteArrayList，是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。

**2.Set**

Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。在一个规则集内，一定不存在两个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。

**2.1HashSet**

散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。

从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。

**2.2LinkedHashSet**

LinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。

**2.3TreeSet**

TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。

**3.Queue**

队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。

上图中，方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。

接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。

### 三、Map接口

**1.HashMap**

HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。我们知道ArrayList主要是用数组来存储元素的，LinkedList是用链表来存储的，那么HashMap的实现原理是什么呢？先看下面这张图：

 ![img](https://upload-images.jianshu.io/upload_images/2243690-ec848d862c725e8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/515)

在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

下面主要通过源码介绍一下它的实现原理。

**HashMap存储元素的数组**

```
  transient Node<K,V>[] table;
```

> 数组的元素类型是Node<K,V>，Node<K,V>继承自Map.Entry<K,V>，表示键值对映射。

```
static class Node<K,V> implements Map.Entry<K,V> {

        final int hash;

        final K key;

        V value;

        Node<K,V> next;

        //构造函数 ( Hash值键值下一个节点 )

        Node(int hash, K key, V value, Node<K,V> next) {

            this.hash = hash;

            this.key = key;

            this.value = value;

            this.next = next;

        }

        public final K getKey()        { return key; }

        public final V getValue()      { return value; }

        public final String toString() { return key + "=" + value; }

        public final int hashCode() {

            return Objects.hashCode(key) ^ Objects.hashCode(value);

        }

        public final V setValue(V newValue) {

            V oldValue = value;

            value = newValue;

            return oldValue;
        }

        public final boolean equals(Object o) {

            if (o == this)

                return true;

            if (o instanceof Map.Entry) {

                Map.Entry<?,?> e = (Map.Entry<?,?>)o;

                if (Objects.equals(key, e.getKey()) && Objects.equals(value, e.getValue())){
                
                    return true;
                    
                }                
            }
            
            return false;
            
        }
    }
```

> 接下来我们看下HashMap的put操作。

```
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,

        boolean evict) {

        Node<K,V>[] tab; Node<K,V> p; int n, i;

        if ((tab = table) == null || (n = tab.length) == 0){
        
            n = (tab = resize()).length;  //如果没有初始化则初始化table
            
        }
        
        if ((p = tab[i = (n - 1) & hash]) == null){
            
            //这里 (n-1)&hash 是根据hash值得到这个元素在数组中的位置（即下标）

            tab[i] = newNode(hash, key, value, null);

           //如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上
        }else {

            Node<K,V> e; K k;

            //第一节节点hash值同，且key值与插入key相同

            if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k)))){

                e = p;

            }else if (p instanceof TreeNode){

                //属于红黑树处理冲突
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);

            }else {

                /链表处理冲突

                for (int binCount = 0; ; ++binCount) {

                    if ((e = p.next) == null) {

                        p.next = newNode(hash, key, value, null);

                        if (binCount >= TREEIFY_THRESHOLD - 1){ // -1 for 1st

                            //新增节点后如果节点个数到达阈值，则将链表转换为红黑树
                            treeifyBin(tab, hash);
                            
                        }
                        break;
                    }

                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))){

                        break;
                    }
                    
                    p = e;
                    
                }
            }
            //更新hash值和key值均相同的节点Value值
            if (e != null) { // existing mapping for key

                V oldValue = e.value;

                if (!onlyIfAbsent || oldValue == null){

                    e.value = value;

                }
                afterNodeAccess(e);

                return oldValue;
            }
        }
        ++modCount;
        
        if (++size > threshold){

            resize();

        }
        afterNodeInsertion(evict);

        return null;
    }
```

> 接下来我们看下HashMap的get操作。

```
  final Node<K,V> getNode(int hash, Object key) {

        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;

        if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) {
            // always check first node
            if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))){

                return first;

            }
            if ((e = first.next) != null) {
                //如果第一个节点是TreeNode,说明采用的是数组+红黑树结构处理冲突

               //遍历红黑树，得到节点值

                if (first instanceof TreeNode){

                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);

                }
                do {
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))){

                        return e;
                        
                    }
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

到这里HashMap的大致实现原理应该很清楚了，有几个需要关注的重点是：HashMap存储元素的方式以及根据Hash值确定映射在数组中的位置还有JDK 1.8之后加入的红黑树的。

> 在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，**(n - 1) & hash**用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，**(n - 1) & hash** 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。

**2.LinkedHashMap**

LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。

**3.TreeMap**

TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。

在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。

**4.ConcurrentHashMap**

Concurrent，并发，从名字就可以看出来ConcurrentHashMap是HashMap的线程安全版。同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高。

 [1]:https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1533816262839&di=a51c0622a7953f68ee7875dda2430a7c&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3046597456%2C4072050019%26fm%3D214%26gp%3D0.jpg
